here’s the next batch to finish the move from “percent bars” to real stage names and to add repeat/redo workflows (repainting, re-sanding, re-cutting, etc.), plus an R&D flag and UI that supports “experiments/repeats and rich notes.”

Everything below is drop-in for the current SvelteKit codebase you’re running.

1) Data model: rework cycles + R&D flag
src/lib/order/stages.ts (extend reasons & helpers)
export type StationTag =
  'CAD'|'CNC'|'SANDING'|'BENDING'|'WELDING'|'PAINT'|'ASSEMBLY'|'QC'|'LOGISTICS';

export type StageState =
  'NOT_STARTED' | 'QUEUED' | 'IN_PROGRESS' | 'BLOCKED' | 'REWORK' | 'COMPLETED';

export type ReworkReason =
  | 'RECUT'      // CNC
  | 'RESAND'     // SANDING
  | 'REBEND'     // BENDING
  | 'REWELD'     // WELDING
  | 'REPAINT'    // PAINT
  | 'REASSEMBLE' // ASSEMBLY
  | 'RECHECK'    // QC
  | 'CUSTOM';

export const REWORK_LABEL: Record<ReworkReason,string> = {
  RECUT:'Re-cut', RESAND:'Re-sand', REBEND:'Re-bend', REWELD:'Re-weld',
  REPAINT:'Re-paint', REASSEMBLE:'Re-assemble', RECHECK:'Re-check', CUSTOM:'Custom'
};

export type StageCycle = {
  idx: number;            // 1,2,3…
  station: StationTag;
  reason: ReworkReason;
  note?: string;
  at: string;             // ISO time
  by: string;             // user id or name
};

export type StageMap = Record<StationTag, StageState>;

export const STATIONS: StationTag[] = [
  'CAD','CNC','SANDING','BENDING','WELDING','PAINT','ASSEMBLY','QC','LOGISTICS'
];

export const STATE_LABEL: Record<StageState,string> = {
  NOT_STARTED:'Not started', QUEUED:'Queued', IN_PROGRESS:'In progress',
  BLOCKED:'Blocked', REWORK:'Rework', COMPLETED:'Completed'
};

export const STATE_TONE: Record<StageState,'primary'|'warn'|'danger'|'success'|'muted'> = {
  NOT_STARTED:'muted', QUEUED:'primary', IN_PROGRESS:'primary',
  BLOCKED:'danger', REWORK:'warn', COMPLETED:'success'
};

export const ALLOWED: Partial<Record<StageState, StageState[]>> = {
  NOT_STARTED:['QUEUED','IN_PROGRESS','BLOCKED'],
  QUEUED:['IN_PROGRESS','BLOCKED'],
  IN_PROGRESS:['REWORK','BLOCKED','COMPLETED'],
  REWORK:['IN_PROGRESS','BLOCKED','COMPLETED'],
  BLOCKED:['IN_PROGRESS','REWORK'],
  COMPLETED:[]
};

export function blankStages(): StageMap {
  return Object.fromEntries(STATIONS.map(s => [s,'NOT_STARTED'])) as StageMap;
}

src/lib/order/types.signage.ts (track rework cycles + R&D flag)
import type { StageMap, StageCycle } from './stages';
export type FileRef = { id:string; name:string; path:string; kind:'pdf'|'img'|'other' };
export type Field = { key:string; label:string; value:string };
export type Material = { key:string; label:string; value:string };
export type Revision = { id:string; file:FileRef; createdBy:string; message?:string; createdAt?:string };

export type Order = {
  id:string; title:string; client:string; due:string;
  loadingDate?: string;
  isRD?: boolean;             // << NEW: R&D order
  rdNotes?: string;           // << NEW
  badges:string[];
  fields: Field[];
  materials: Material[];
  stages: StageMap;
  cycles?: StageCycle[];      // << NEW: log of “repeat” cycles
  defaultBranch:string; branches:any[];
  prs:any[]; revisions:Revision[]; defaultRevisionId:string;
  file?: FileRef;
};

2) Store: Admin actions for Send to Rework and Apply Stage
src/lib/order/signage-actions.ts
import { openChangeRequest, approveChangeRequest, getOrder } from './signage-store';
import type { StationTag, ReworkReason, StageCycle, StageState } from './stages';

export function adminSendToRework(orderId:string, station:StationTag, reason:ReworkReason, note:string, admin='admin'){
  const o = getOrder(orderId); if (!o) return;
  const prId = openChangeRequest(orderId, {
    title:`${station}: rework (${reason})`,
    author: admin,
    proposed: { stages:{ [station]:'REWORK' } },
    note
  });
  approveChangeRequest(orderId, prId, admin);

  const idx = (o.cycles?.length || 0) + 1;
  const cycle: StageCycle = { idx, station, reason, note, at:new Date().toISOString(), by: admin };
  o.cycles = [...(o.cycles||[]), cycle];
}

export function adminApplyStage(orderId:string, station:StationTag, next:StageState, note='', admin='admin'){
  const prId = openChangeRequest(orderId, {
    title:`${station} → ${next}`, author: admin,
    proposed: { stages:{ [station]: next } }, note
  });
  approveChangeRequest(orderId, prId, admin);
}


These keep the audit trail via Change Requests, then auto-approve (admin).

3) UI: StageLegend now shows cycles (x2, x3…) and tooltips
src/lib/order/StageLegend.svelte (replace)
<script lang="ts">
  import Badge from '$lib/ui/Badge.svelte';
  import { STATE_LABEL, STATE_TONE, STATIONS, type StageCycle } from './stages';
  export let stages: Record<string,string> = {};
  export let cycles: StageCycle[] = [];

  function count(s: string){ return cycles.filter(c => c.station===s).length; }
  function detail(s: string){
    return cycles.filter(c=>c.station===s).map(c=>`${c.idx}. ${c.reason}${c.note?` – ${c.note}`:''}`).join('\n');
  }
</script>

<div class="card">
  <h3 style="margin:0 0 8px 0">Process</h3>
  <ul style="display:grid;gap:8px">
    {#each STATIONS as s}
      <li class="row" style="justify-content:space-between; align-items:center">
        <span class="row" style="gap:6px">
          <b>{s}</b>
          {#if count(s)>0}
            <span class="tag badge-warn" title={detail(s)}>x{count(s)} repeat</span>
          {/if}
        </span>
        <Badge tone={STATE_TONE[stages[s]]}>{STATE_LABEL[stages[s]]}</Badge>
      </li>
    {/each}
  </ul>
</div>

4) UI: Quick Rework (Admin) and extended Stage Editor
src/lib/order/ReworkQuick.svelte
<script lang="ts">
  import { STATIONS, type StationTag, type ReworkReason, REWORK_LABEL } from './stages';
  import Input from '$lib/ui/Input.svelte';
  import Button from '$lib/ui/Button.svelte';

  export let onSend: (station:StationTag, reason:ReworkReason, note:string)=>void = ()=>{};
  let station: StationTag = 'CNC';
  let reason: ReworkReason = 'RECUT';
  let note = '';

  const OPTIONS: Record<StationTag, ReworkReason[]> = {
    CAD:['CUSTOM'],
    CNC:['RECUT','CUSTOM'],
    SANDING:['RESAND','CUSTOM'],
    BENDING:['REBEND','CUSTOM'],
    WELDING:['REWELD','CUSTOM'],
    PAINT:['REPAINT','CUSTOM'],
    ASSEMBLY:['REASSEMBLE','CUSTOM'],
    QC:['RECHECK','CUSTOM'],
    LOGISTICS:['CUSTOM']
  };
</script>

<div class="card">
  <h3 style="margin:0 0 8px 0">Send to Rework</h3>
  <div class="grid" style="grid-template-columns:1fr 1fr">
    <div>
      <label class="muted">Station</label>
      <select class="rf-input" bind:value={station}>
        {#each STATIONS as s}<option value={s}>{s}</option>{/each}
      </select>
    </div>
    <div>
      <label class="muted">Reason</label>
      <select class="rf-input" bind:value={reason}>
        {#each OPTIONS[station] as r}<option value={r}>{REWORK_LABEL[r]}</option>{/each}
      </select>
    </div>
    <div style="grid-column:span 2"><Input bind:value={note} placeholder="Note for production" /></div>
  </div>
  <div class="row" style="margin-top:8px"><Button on:click={()=>onSend(station,reason,note)}>Send</Button></div>
</div>


Use in Order → Changes (Admin):

<script>
  import ReworkQuick from '$lib/order/ReworkQuick.svelte';
  import { adminSendToRework } from '$lib/order/signage-actions';
  function sendRework(station, reason, note){
    adminSendToRework(o.id, station, reason, note, 'admin');
    o = getOrder(id)!;
  }
</script>
<ReworkQuick onSend={sendRework} />


StageEditor from the previous batch already drives normal transitions.

5) Order Form: R&D flag + rich notes
src/lib/order/OrderForm.svelte (add fields & persist)
<script lang="ts">
  // ...existing imports
  let isRD = false;     // NEW
  let rdNotes = '';     // NEW
  // in create():
  createOrder({
    id, title, client, due, isRD, rdNotes,
    badges: isRD ? ['OPEN','R&D'] : ['OPEN','IN_PROGRESS'],
    // ...
  });
</script>

<!-- Basics card: add -->
<div style="grid-column:span 2" class="row">
  <label class="tag"><input type="checkbox" bind:checked={isRD} /> R&D order</label>
</div>
{#if isRD}
  <div style="grid-column:span 2">
    <label class="muted">R&D notes (visible to all stations)</label>
    <textarea class="rf-input" rows="3" bind:value={rdNotes}></textarea>
  </div>
{/if}


Show R&D on the Order page header as a tag (and maybe pin the notes in Overview).

6) Notifications + chat updates for rework/completion

Where you approve/apply stage or send to rework, broadcast:

import { sendMessage } from '$lib/chat/chat-store';
import { notify } from '$lib/ui/notifications';
import type { StationTag } from '$lib/order/stages';

function broadcast(orderId:string, station:StationTag, text:string, mentions:string[]=[]){
  notify(`${orderId} · ${station}: ${text}`);
  sendMessage('workstations', `${orderId} · ${station}: ${text}`, mentions);
}


On adminSendToRework → broadcast(o.id, station, 'rework requested', assignees[station])

On adminApplyStage(..., 'COMPLETED') → broadcast(..., 'completed', assignees[station])

(Assuming you keep assignees map on the order as before.)

7) Dashboard metrics updated for stages & rework
src/lib/metrics/order-metrics.ts (add rework counts)
import type { Order } from '$lib/order/types.signage';
import { STATIONS } from '$lib/order/stages';

export function summarize(orders: Order[]) {
  const stageBuckets: Record<string, number> = {};
  const reworkCounts: Record<string, number> = {};
  for (const s of STATIONS) for (const k of ['NOT_STARTED','QUEUED','IN_PROGRESS','BLOCKED','REWORK','COMPLETED'])
    stageBuckets[`${s}:${k}`] = 0;

  let blocked = 0, completed = 0, rd = 0, reworks = 0;

  for (const o of orders) {
    if (o.isRD) rd++;
    for (const s of STATIONS) {
      const st = o.stages[s];
      stageBuckets[`${s}:${st}`]++;
      const c = (o.cycles||[]).filter(x => x.station===s).length;
      reworkCounts[s] = (reworkCounts[s]||0) + c;
      reworks += c;
    }
    if (Object.values(o.stages).every(v => v==='COMPLETED')) completed++;
    if (Object.values(o.stages).includes('BLOCKED')) blocked++;
  }
  return { stageBuckets, reworkCounts, blocked, completed, rd, total: orders.length, reworks };
}


Use on Dashboard: show R&D orders, Blocked orders, Total reworks, Top stations by rework.

8) i18n keys to add

Append to locales/en.json (mirror to RU/LV):

{
  "rework": {
    "send": "Send to Rework",
    "reason": "Reason",
    "note": "Note for production",
    "x_repeat": "repeat",
    "reasons": {
      "RECUT": "Re-cut",
      "RESAND": "Re-sand",
      "REBEND": "Re-bend",
      "REWELD": "Re-weld",
      "REPAINT": "Re-paint",
      "REASSEMBLE": "Re-assemble",
      "RECHECK": "Re-check",
      "CUSTOM": "Custom"
    }
  },
  "rd": {
    "flag": "R&D order",
    "notes": "R&D notes (visible to all stations)"
  },
  "stages": {
    "NOT_STARTED": "Not started",
    "QUEUED": "Queued",
    "IN_PROGRESS": "In progress",
    "BLOCKED": "Blocked",
    "REWORK": "Rework",
    "COMPLETED": "Completed"
  }
}

9) Operational guidance for the team

Stations now update via Stage Editor (“In progress”, “Completed”). If something went wrong, ping Admin; Admin uses Send to Rework (select station + reason + note).

R&D orders show a yellow “R&D” tag and fixed R&D notes box in Overview—read first, then proceed. Expect repeats; “Rework” is common and logged.

Chat: @mention station users when a rework is requested or a stage completes; messages land in Workstations room.

Calendar/Loading: unchanged; still pick the loading day in the form or assign later.