next batch coming in hot. This one delivers:

Loading Dates: assign/change from an existing order, view daily schedule, export CSV manifest.

Order Form: color validators (HEX/RAL), clearer UX.

User directory & roles (Admins/Stations) to drive chat presence.

Chat v2: rooms, @mentions with autocomplete, per-room persistence-ready state.

Right rail: fixed viewport; notifications and chat each scroll without resizing the page.

All i18n-ready; just mirror the keys to RU/LV.

Everything below is drop-in for your SvelteKit codebase.

1) Users & Roles (directory + current user)
src/lib/users/user-store.ts
import { writable, derived } from 'svelte/store';

export type Role = 'Admin' | 'Station';
export type StationTag = 'CAD'|'CNC'|'SANDING'|'BENDING'|'WELDING'|'PAINT'|'ASSEMBLY'|'QC'|'LOGISTICS';

export type User = {
  id: string;
  name: string;
  role: Role;
  stations?: StationTag[];
};

const KEY_USER = 'rf_current_user';

export const users = writable<User[]>([
  { id:'u-admin',   name:'Admin',   role:'Admin' },
  { id:'u-cnc1',    name:'CNC-1',   role:'Station', stations:['CNC'] },
  { id:'u-sanding', name:'Sanding', role:'Station', stations:['SANDING'] },
  { id:'u-welding', name:'Welding', role:'Station', stations:['WELDING'] },
  { id:'u-paint',   name:'Paint',   role:'Station', stations:['PAINT'] }
]);

const start = typeof window!=='undefined' ? localStorage.getItem(KEY_USER) : null;
export const currentUserId = writable<string>(start || 'u-admin');
currentUserId.subscribe(v => { if (typeof window!=='undefined') localStorage.setItem(KEY_USER, v); });

export const currentUser = derived([users, currentUserId], ([$users, $id]) => $users.find(u=>u.id===$id) || $users[0]);

Minimal switcher (add to Settings or Launchpad)
<!-- src/lib/users/UserSwitch.svelte -->
<script lang="ts">
  import { users, currentUserId } from './user-store';
  $: $users, $currentUserId;
</script>

<div class="card">
  <h3 style="margin:0 0 8px 0">User</h3>
  <select class="rf-input" bind:value={$currentUserId} aria-label="Current user">
    {#each $users as u}<option value={u.id}>{u.name} — {u.role}</option>{/each}
  </select>
</div>


Add <UserSwitch /> to /settings or /launchpad as you prefer.

2) Chat v2 — rooms, mentions, fixed right-rail behavior
2.1 Chat types + store (local, backend-ready)
src/lib/chat/types.ts
export type Room = { id: string; name: string; private?: boolean; members?: string[] }; // user ids
export type Message = {
  id: string; roomId: string; authorId: string; ts: string; text: string;
  mentions?: string[]; // user ids
};

src/lib/chat/chat-store.ts
import { writable, get } from 'svelte/store';
import type { Room, Message } from './types';
import { users, currentUser } from '$lib/users/user-store';

const KEY_ROOMS = 'rf_chat_rooms';
const KEY_MSGS = 'rf_chat_msgs';

function load<T>(k:string, d:T){ if (typeof window==='undefined') return d; try { return JSON.parse(localStorage.getItem(k)||''); } catch { return d; } }
function save<T>(k:string, v:T){ if (typeof window==='undefined') return; localStorage.setItem(k, JSON.stringify(v)); }

export const rooms = writable<Room[]>(load(KEY_ROOMS, [
  { id:'general', name:'General' },
  { id:'workstations', name:'Workstations' },
  { id:'logistics', name:'Logistics' }
]));
rooms.subscribe(v => save(KEY_ROOMS, v));

export const messages = writable<Message[]>(load(KEY_MSGS, []));
messages.subscribe(v => save(KEY_MSGS, v));

export function sendMessage(roomId: string, text: string, mentions: string[] = []) {
  const me = get(currentUser);
  const msg: Message = {
    id: crypto.randomUUID(),
    roomId, authorId: me.id,
    ts: new Date().toISOString(),
    text, mentions
  };
  messages.update(a => [...a, msg]);
}

2.2 Mentions autocomplete
src/lib/chat/MentionInput.svelte
<script lang="ts">
  import { users } from '$lib/users/user-store';
  import { onMount } from 'svelte';

  export let value = '';
  export let onCommit: (text: string, mentions: string[]) => void = () => {};
  let inputEl: HTMLTextAreaElement;

  let showList = false;
  let list: {id:string;name:string}[] = [];
  let picked: string[] = []; // user ids mentioned

  $: $users;

  function onKey(e: KeyboardEvent){
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      onCommit(value.trim(), [...picked]);
      value=''; picked=[]; showList=false;
    }
  }
  function scanMentions(){
    const m = value.match(/@([a-z0-9\-\_ ]{1,32})$/i);
    if (!m) { showList=false; return; }
    const q = m[1].toLowerCase();
    list = $users.filter(u => u.name.toLowerCase().includes(q)).map(u=>({id:u.id,name:u.name}));
    showList = list.length>0;
  }
  function choose(u:{id:string;name:string}){
    value = value.replace(/@([a-z0-9\-\_ ]{1,32})$/i, `@${u.name} `);
    picked = Array.from(new Set([...picked, u.id]));
    showList=false;
    inputEl.focus();
  }
</script>

<div class="mention-wrap">
  <textarea bind:this={inputEl} class="rf-input" rows="2" bind:value={value}
    placeholder="Message (use @name to mention)" on:input={scanMentions} on:keydown={onKey} />
  {#if showList}
    <div class="mention-list" role="listbox">
      {#each list as u}<button class="mention-item" on:click={() => choose(u)}>@{u.name}</button>{/each}
    </div>
  {/if}
</div>

<style>
.mention-wrap { position:relative }
.mention-list { position:absolute; left:0; bottom:calc(100% + 6px); background:var(--bg-1); border:1px solid rgba(255,255,255,.12); border-radius:8px; padding:6px; display:grid; gap:4px; max-height:160px; overflow:auto; width:min(360px, 90vw); }
.mention-item { text-align:left }
</style>

2.3 Chat pane with rooms & fixed viewport
src/lib/ui/ChatPane.svelte (replace)
<script lang="ts">
  import { rooms, messages, sendMessage } from '$lib/chat/chat-store';
  import { currentUser, users } from '$lib/users/user-store';
  import MentionInput from '$lib/chat/MentionInput.svelte';

  let activeRoom = 'general';
  $: $rooms, $messages, $currentUser, $users;

  function commits(text: string, mentions: string[]){
    if (!text) return;
    sendMessage(activeRoom, text, mentions);
  }

  function roomName(id:string){ return $rooms.find(r=>r.id===id)?.name || id; }
  function userName(id:string){ return $users.find(u=>u.id===id)?.name || id; }
</script>

<div class="rf-panel chat" aria-label="Chat">
  <header class="chat-head">
    <div class="tabs">
      {#each $rooms as r}
        <button class="tag" aria-pressed={activeRoom===r.id} on:click={()=>activeRoom=r.id}>{r.name}</button>
      {/each}
    </div>
    <div class="muted">You: {$currentUser.name}</div>
  </header>

  <div class="chat-scroll" id="chat-scroll" tabindex="0" aria-live="polite">
    {#each $messages.filter(m=>m.roomId===activeRoom) as m (m.id)}
      <div class="msg">
        <div class="row" style="justify-content:space-between">
          <b>{userName(m.authorId)}</b>
          <span class="muted" style="font-size:.8rem">{new Date(m.ts).toLocaleString()}</span>
        </div>
        <p style="margin:.25rem 0 .5rem 0; white-space:pre-wrap">{m.text}</p>
        {#if m.mentions?.length}
          <div class="muted" style="font-size:.85rem">Mentioned: {m.mentions.map(userName).join(', ')}</div>
        {/if}
      </div>
    {/each}
  </div>

  <div class="chat-input">
    <MentionInput onCommit={commits} />
  </div>
</div>

<style>
.chat { display:grid; grid-template-rows: auto 1fr auto; min-height:0 }
.chat-head { display:flex; justify-content:space-between; align-items:center; gap:8px }
.chat-scroll { overflow:auto; min-height:0; max-height:unset; padding-right:2px }
.msg { background:var(--bg-2); border-radius:10px; padding:8px; }
.chat-input { border-top:1px solid rgba(255,255,255,.08); padding-top:6px }
</style>

2.4 Right-rail fixed viewport (notifications don’t resize page)

Add/adjust CSS:

static/brand.css (append)

/* Right rail never resizes the page: it scrolls internally */
.rf-right { display:grid; grid-template-rows: 220px 1fr; min-height: 0; }
.rf-right > * { min-height: 0; }

.rf-panel { min-height:0; display:grid; grid-template-rows:auto 1fr; overflow:hidden; }
.rf-panel .rf-scroll { overflow:auto; min-height:0; }


If your Notifications panel uses .rf-scroll, it will scroll inside its fixed height instead of pushing the layout.

3) Loading Dates UX: assign/change on existing orders; daily schedule; export CSV
3.1 Assign/change on order page (Admin)

Add a small panel in orders/[id] (Overview sidebar):

<script>
  import LoadingDatePicker from '$lib/order/LoadingDatePicker.svelte';
  import { setLoadingDate } from '$lib/order/signage-store';
  let pick = (o as any).loadingDate || '';
  function assign() {
    if (!pick) return;
    setLoadingDate(o.id, pick, 'admin');
    o = getOrder(id)!;
  }
</script>

<section class="card">
  <h3 style="margin:0 0 8px 0">Loading Date</h3>
  <LoadingDatePicker bind:selected={pick} />
  <div class="row" style="margin-top:8px"><button class="tag" on:click={assign}>Assign</button></div>
</section>

3.2 Daily schedule in Calendar page + Export CSV
src/lib/export/csv.ts
export function toCSV(rows: Record<string, any>[], headerOrder?: string[]) {
  if (!rows.length) return '';
  const headers = headerOrder || Object.keys(rows[0]);
  const esc = (v:any) => {
    const s = v == null ? '' : String(v);
    return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
  };
  return [ headers.join(','), ...rows.map(r => headers.map(h => esc(r[h])).join(',')) ].join('\n');
}

export function downloadCSV(filename: string, csv: string) {
  const blob = new Blob([csv], { type:'text/csv;charset=utf-8' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

Update src/routes/calendar/+page.svelte (append under <CalendarMonth />)
<script>
  import { listOrders } from '$lib/order/signage-store';
  import { downloadCSV, toCSV } from '$lib/export/csv';
  import { listAll } from '$lib/loading/loading-store';

  let selectedISO: string | null = null; // set by CalendarMonth? We'll add a binding
  function onPicked(e) { selectedISO = e.detail; }

  function schedule(iso:string) {
    const all = listOrders() as any[];
    return all.filter(o => o.loadingDate === iso)
      .map(o => ({
        PO: o.id, Client: o.client, Title: o.title, Due: o.due, Loading: o.loadingDate
      }));
  }
  function exportCSV() {
    if (!selectedISO) return;
    const rows = schedule(selectedISO);
    downloadCSV(`loading-${selectedISO}.csv`, toCSV(rows, ['PO','Client','Title','Due','Loading']));
  }
</script>

<!-- Modify CalendarMonth to dispatch selected day when clicked in either mode -->
<CalendarMonth {year}={y} {month}={m} {adminMode} on:selectDay={onPicked} />

{#if selectedISO}
  <section class="card" style="margin-top:10px">
    <div class="row" style="justify-content:space-between;align-items:center">
      <h3 style="margin:0">Schedule: {selectedISO}</h3>
      <button class="tag" on:click={exportCSV}>Export CSV</button>
    </div>
    <table class="rf-table">
      <thead><tr><th>PO</th><th>Client</th><th>Title</th><th>Due</th></tr></thead>
      <tbody>
        {#each schedule(selectedISO) as r}
          <tr><td>{r.PO}</td><td>{r.Client}</td><td>{r.Title}</td><td>{r.Due}</td></tr>
        {/each}
        {#if schedule(selectedISO).length===0}<tr><td colspan="4" class="muted">No orders assigned.</td></tr>{/if}
      </tbody>
    </table>
  </section>
{/if}

Update src/lib/calendar/CalendarMonth.svelte to emit selected day

Add inside <script>:

import { createEventDispatcher } from 'svelte';
const dispatch = createEventDispatcher();


Modify clickDay(iso):

function clickDay(iso: string) {
  if (!adminMode) { selectedISO = iso; dispatch('selectDay', iso); return; }
  toggleDay(iso);
  selectedISO = iso;
  dispatch('selectDay', iso);
}

4) Order Form — color validators & hints

Update in src/lib/order/OrderForm.svelte:

Add HEX validator:

<script>
  function validHex(s:string){ return /^#?[0-9a-f]{6}$/i.test(s||''); }
</script>


Where HEX is edited:

{#if r.color.system === 'HEX'}
  <Input bind:value={r.color.code} placeholder="#RRGGBB" />
  {#if r.color.code && !validHex(r.color.code)}<div class="muted" style="color:#ff5d5d">Invalid HEX</div>{/if}
{:else}
  <Input bind:value={r.color.hex} placeholder="Optional HEX override" />
  {#if r.color.hex && !validHex(r.color.hex)}<div class="muted" style="color:#ff5d5d">Invalid HEX</div>{/if}
{/if}


You can also display suggested RAL list with a small dropdown later.

5) i18n keys to add (EN; mirror to RU/LV)

Append to locales/en.json:

{
  "chat": {
    "rooms": "Rooms",
    "message_placeholder": "Message (use @name to mention)"
  },
  "loading": {
    "assign": "Assign",
    "schedule": "Schedule",
    "export_csv": "Export CSV"
  },
  "users": {
    "current": "User"
  }
}

6) Notes on backend readiness

Chat: store already separates rooms and messages → when backend comes, swap sendMessage with API and live updates via SSE/WebSocket.

Loading days: the loading-store API is 1:1 swappable to a REST/DB service. usage() will become a server aggregate.

Uploads: form currently pastes a static path; later introduce UploadService with getUploadUrl() → store the resulting URL and push a file-revision commit.